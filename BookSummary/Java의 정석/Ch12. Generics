1.5에 도입된 지네릭스를 완전히 이해하긴 힘들다. 이 장에서는 기본 정도를 익히고, 다른 장에서 어떻게 활용되는지 알아보자.

## 1. 1 지네릭스란?

- 타입 체크를 **컴파일 시**에 하는 기능.
- 객체의 타입 안정성을 높이고, 형변환의 번거로움을 줄여준다.
  (하나의 컬렉션에는 대부분 한 종류의 객체만 저장한다)

장점

- 타입 안정성
- 코드 간결(타입체크와 형변환을 생략하므로)

## 1. 2 지네릭 클래스의 선언

```java
// before
class Box {
  Object item;

  void setItem(Object item) {
    this.item = item;
  }

  Object getItem() {
    return item;
  }
}

// after
class Box<T> {    // 지네릭 T 선언
  T item;

  void setItem(T item) {
    this.item = item;
  }

  T getItem() {
    return item;
  }
}
```

참조변수, 생성자에 T 대신 실제 타입을 지정하면 형변환 생략 가능

```java
Box<String> b=new Box<String>();     // 실제 타입 지정
    b.setItem(new Object());               // 에러. String만 가능
    b.setItem("ABC");                      // ok
    String item=(String)b.getItem();    // 형변환 필요 없음
```

### 1. 2.2 용어

- Box<T> : 지네릭 클래스. T의 Box 혹은 T Box라고 읽는다.
- T : 타입 변수 혹은 타입 매개변수. (T는 타입 문자)
- Box : 원시 타입(raw type)

### 1. 2.2 제약사항

- static 멤버에는 타입 변수 T를 사용할 수 없다.

    ```java
    class Box<T> {
      static T item;     // 에러
      static int compare(T t1, T t2){...}   // 에러
    }
    ```

- T[] 배열을 **생성**할 수는 없다.

    ```java
    class Box<T> {
      T[] itemArr;
      T[] toArray(){
        T[] arr = new T[itemArr.length];       // 에러
      }
    }
    ```

## 1. 3 객체 생성과 사용

- 지네릭 클래스 Box<T>의 선언

  ```java
  class Box<T> {
    ArrayList<T> list = new ArrayList<T>();
  
    void add(T item) {
      list.add(item);
    }
  
    T get(int i) {
      return list.get(i);
    }
  
    ArrayList<T> getList() {
      return list;
    }
  
    int size() {
      return list.size();
    }
  
    public String toString() {
      return list.toString();
    }
  }
  ```
- Box<T>의 객체 생성. 참조 현수와 생성자에 대입된 타입이 일치해야한다.
  ```java
  Box<Apple> appleBox = new Box<Apple>();
  Box<Apple> appleBox1 = new Box<Grape>();  // 에러
  Box<Fruit> appleBox2 = new Box<Apple>();  // 에러
  Box<Apple> appleBox3 = new Box<Fruit>();  // 에러
  ```
- 두 지네릭 클래스가 상속관계이고, 대입된 타입이 일치하는 것은 가능
  ```java
  Box<Apple> appleBox = new FruitBox<Apple>();  // 다형성
  Box<Apple> appleBox = new Box<>();  // JDK 1.7부터 생략 가능    
  ```
- 대입된 타입과 다른 타입의 객체는 추가할 수 없다.
  ```java
  Box<Apple> appleBox = new Box<Apple>();
  appleBox.add(new Apple());
  appleBox.add(new Grape());    // 에러   
  ```
## 1. 4 제한된 지네릭 클래스
- 지네릭 타입에 extends를 사용하여 타입을 특정한다.
```java
class FruitBox<T extends Fruit> {
  ArrayList<T> list = new ArrayList<>();
  void add(T item){list.add(item);}
}
// add()의 매개변수 타입도 Fruit과 그 자손 타입이다.
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
fruitBox.add(new Apple());
fruitBox.add(new Grape());
// 인터페이스도 extends를 사용
interface Eatable(){}
class FruitBox<T extends Eatable>{}
class FruitBox<T extends Eatable & Fruit>{}
```
## 1. 5 와일드 카드 '?'
- 지네릭 타입에 와일드 카드를 쓰면, 여러 타입을 대입할 수 있다. 
단, 와일드 카드에는 extends 시에 &를 쓸 수 없다.
  - <? extends T> : 와일드 카드의 상한 제한. T와 그 자손만 가능
  - <? super T> : 와일드 카드의 하한 제한. T와 그 조상들만 가능
  - <?> : 제한 없음. <? extends Object>와 동일.
  ```java
  static Juice makeJuice(FruitBox<? extends Fruit> box){
    String temp = "";
    for(Fruit f: box.getList()) temp += f + " ";
    return new Juice(temp);
  }
  
  FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
  FruitBox<Apple> appleBox = new FruitBox<Apple>();
      ...
  System.out.println(Juicer.makeJuice(fruitBox));
  System.out.println(Juicer.makeJuice(appleBox));
  ```
## 1. 6 지네릭 메서드
- 반환타입 앞에 지네릭 타입이 선언된 메서드
  ```java
  static <T> void sort(List<T> list, Comparator<? super T> c){}
  ```
- 클래스의 타입 매개변수 T와 메서드의 타입 매개변수 T는 별개
  ```java
  class FruitBox<T>{
    static <T> void sort(List<T> list, Comparator<? super T> c){}
  }
  ```
- 지네릭 메서드를 호출할 때, 타입 변수에 타입을 대입해야 한다.
 (대부분의 경우 추정이 가능해서 생략 가능)
  ```java
  FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
  FruitBox<Apple> appleBox = new FruitBox<Apple>();
      ...
  System.out.println(Juicer.<Fruit>makeJuice(fruitBox));
  System.out.println(Juicer.makeJuice(appleBox));
  ```
## 1. 7 지네릭의 형변환
1. 지네릭과 원시 타입간의 형변환은 불가능
2. 와일드 카드가 사용된 지네릭 타입으로는 형변환 가능
3. <? extends Object> == <?>
```java
// 1
Box box = null;
Box<Object> objBox = null;
Box<String> strBox = null;

box = (Box)objBox;          // 가능. 경고는 발생
objBox = (Box<Object>)box;  // 가능. 경고는 발생
objBox = (Box<String>)box;  // 불가능. 
strBox = (Box<Object>)box;  // 불가능.
// Box<Object> objBox = new Box<String>(); 이 안되는 것과 동일
    
Box<? extends Object> wBox = new Box<String>(); // 가능

static Juice makeJuice(FruitBox<? extends Fruit> box){...}
// 하단은 모두 가능. 반대도 되지만, 확인되지 않은 형변환이라는 경고 발생
FruitBox<? extends Fruit> box = new FruitBox<Fruit>();
FruitBox<? extends Fruit> box = new FruitBox<Apple>();
FruitBox<? extends Fruit> box = new FruitBox<Grape>();

FruitBox<? extends Fruit> box = null;
FruitBox<Apple> appleBox = (Fruit<Apple>)box;   // Ok. 미확인 타입으로 형변환 경고
```
###예제
```java
public final class Optional<T> {
  private static final Optional<?> EMPTY = new Optional<>();
  private final T value;

  // ...
  public static <T> Optional<T> empty() {
    Optional<T> t = (Optional<T>) EMPTY;
    return t;
  }
//   Optional<?> EMPTY = new Optional<>(); 
//-> Optional<? extends Object> EMPTY = new Optional<>();
//-> Optional<? extends Object> EMPTY = new Optional<Object>();
}
```
``Optional<?> EMPTY = new Optional<?>();``
는 에러

``class Box<T extends Fruit>``의 경우,``Box<?> b = new Box<>();``는 ``Box<?> b = new Box<Fruit>();``이다

위의 문장에서 ``Optional<Object>``가 아닌 ``Optional<?>``로 한 이유는 ``Optional<T>``로 형변환이 가능하기 때문.
```java
Optional<?> wopt = new Optional<Object>();
Optional<Object> oopt = new Optional<Object>();

Optional<String> sopt = (Optional<String>)wopt; // OK
Optional<String> sopt = (Optional<String>)oopt; // error
```
다음과 같이 와일드 카드가 사용된 지네릭 타입끼리도 다음과 같은 경우에는 형변환이 가능하다.
```java
FruitBox<? extends Object> objBox = null;
FruitBox<? extends String> strBox = null;

strBox = (FruitBox<? extends Object>)objBox; // OK. 미확정 타입으로 형변환 경고
objBox = (FruitBox<? extends String>)strBox; // OK. 미확정 타입으로 형변환 경고
```
와일드 카드는 타입이 확정된 것이 아니기 때문에 컴파일러는 경고를 출력한다.
## 1. 8 지네릭 타입의 제거
컴파일된 파일(*.class)은 지네릭 타입에 대한 정보가 없다. 이유는 지네릭 도입 전의 소스코드와 호환성을 유지하기 위해서이다. 앞으로는 하위 호환성을 포기하게 될 때를 위해서 원시 타입을 사용하지 않도록 하자.
###1. 지네릭 타입의 경계(bound) 제거
```java
// before
class Box<T extends Fruit>{
  void add(T t){
//    ...
  }
}

//after 
class Box{
  void add(Fruit t){
//    ...
  }
}
//<T> -> Object
```
###2. 타입이 일치하지 않으면, 형변환
```java
// before
T get(int i){
  // Object 반환
  return list.get(i);
}

//after 
Fruit get(int i){
  return (Fruit)list.get(i);
}
//<T> -> Object
```
###3. 와일드 카드
```java
// before
static Juice makeJuice(FruitBox<? extends Fruit> box){
  String temp = "";
  for(Fruit f: box.getList()) temp += f + " ";
  return new Juice(temp);
}

// after
static Juice makeJuice(FruitBox box){
  String temp = "";
  Iterator it = box.getList().iterator();
  while(it.hasNext()) temp += (FruitBox)it.next() + " ";
  return new Juice(temp);
}
```

#2. 열거형(enums)
##2.1 열거형이란?
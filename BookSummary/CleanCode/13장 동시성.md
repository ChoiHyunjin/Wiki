# 13장 동시성

# Questions

1. 

# Organize

## 동시성이 필요한 이유

1. 구조적 개선

    동시성은 **무엇**과 **언제**를 ****분리하는, **결합**을 없애는 전략.

2. 작업 처리량 개선

    응답 시간과 작업 처리량을 개선하기 위한 목적

### 미신과 오해

- 항상 성능을 높여준다

    => **때로** 성능을 높여준다

- 동시성을 구현해도 계는 변하지 않는다

    => 단일/다중 스레드 시스템 설계는 완전 다르다.

- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.

    => 실제론 컨테이너가 어떻게 동작하는지, 동시수정/데드락 같은 문제를 어떻게 피할 지 알아야 한다.

### 타당한 생각

- 동시성은 부하를 유발한다.
- 복잡하다.
- 버그 재현이 어렵다.
- 근본적인 설계 전략을 재고해야 한다.

## 난관

## 동시성 방어 원칙

### 단일 책임 원칙

SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다. 그러므로 동시성은 복잡성 하나만으로 **따로 분리해야 한다**.

동시성 구현 시 고려 요소

- 독자적인 개발, 변경, 조율 주기가 있다.
- 독자적 난관이 있다.
- 버라이어티한 실패들이 나타난다. 동시성 자체만으로도 충분히 어렵다.

### 따름 정리 ( 자료 범위를 제한하라 )

객체 하나를 두 스레드가 동일 필드를 수정하여 서로 간섭하는 문제가 발생한다.

이 문제를 해결하는 방안으로 공유 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호한다. 그리고 임계영역의 수를 줄이는 기술이 중요하다.

** 권장사항 : 자료를 **캡슐화**. 공유 자료를 **최소화**.

### 따름 정리 ( 자료 사본을 사용하라 )

객체를 복사해 읽기 전용으로 사용하거나, 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다.

즉, 사본으로 동기화를 피해 내부 잠금을 없애자.

### 따름 정리 ( 스레드는 가능한 독립적으로 )

가능하면 다른 프로세서에서 독자적인 스레드로 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.

## 라이브러리를 이해하라

자바5로 스레드 코드 구현 시 고려 사항

- 스레드 환경에 안전한 컬렉션 사용
- 서로 무관한 작업 수행 시 executor 프레임워크 사용
- 가능하다면 스레드가 차단되지 않는 방법 사용
- 일부 클래스 라이브러리는 스레드에 안전하지 못함

### 스레드 환경에 안전한 컬렉션

- ReentrantLock : 한 메서드에서 잠그고 다른 메서드에서 푸는 락
- Semaphore : 세마포어
- CountDownLatch : 지정한 수 만큼 이벤트 발생하고서야 대기 중인 스레드를 모두 해제하는 락. 모든 스레드가 공평하게 시작할 수 있다.

**권장사항 : 언어가 제공하는 클래스 검토 ( 자바 : java.util.concurrent, atomic, concurrent.locks 패키지 사용)

## 실행 모델 이해

** 다중 스레드 관련 용어

- 한정된 자원
- 상호 배제 : 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우
- 기아 : 굉장히 오래 혹은 영원히 자원을 기다린다.
- 데드락
- 라이브락

### 생산자-소비자

하나 이상 생산자 스레드가 정보를 생성해 버퍼*buffer*나 대기열*Queue*에 넣는다.

하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다.

생산자/소비자가 사용하는 대기열은 **한정된 자원**이다.

생산자 스레드는 대기열에 빈 공간이 있어야 정보를 채운다. 빈 공간이 생길 때까지 기다린다.

소비자 스레드는 대기열에 정보가 있어야 가져온다. 정보가 채워질 때까지 기다린다.

생산자 스레드는 정보를 채운 다음 소비자 스레드에게 시그널을 보낸다.

소비자 스레드는 대기열에서 정보를 읽은 후 시그널을 보낸다.

잘못하면 생산자/소비자 스레드 모두 진행 가능함에도, 여전히 시그널을 기다릴 가능성이 존재한다.

### 읽기-쓰기

읽기 쓰레드 - 주된 정보원으로 공유 자원 사용

쓰기 쓰레드 - 공유 자원을 가끔 갱신

이런 경우 처리율이 중요.

- 처리율을 강조하면 기아현상이 생기거나 오래된 정보가 쌓인다.
- 갱신을 허용하면 처리율에 영향을 미친다.

일반적으로 쓰기 스레드가 버퍼를 오래 점유해서 읽기 스레드들이 버퍼를 기다리느라 처리율이 떨어진다.

- 읽기 스레드에 우선권 주기 : 읽기 스레드가 없을 때 까지 쓰기 스레드가 버퍼를 기다리는 방법. 쓰기 스레드가 기아 상태에 빠질 수 있다.
- 쓰기 스레드에 우선권 주기 :쓰기 스레드가 계속 이어진다면 처리율이 떨어짐.

### 식사하는 철학자들

![Untitled](images/13장%20동시성/Untitled.png)

조건

1. 철학자는 식사 시 양손에 포크를 사용한다.
2. 양손에 포크를 쥐지 못하면 먹지 못한다.
3. 양손에 포크를 쥘 때까지 기다려야 한다.

데드락, 라이브락, 처리율 저하 등이 발생 할 수 있다.

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.

공유 클래스 하나에 동기화된 메서드가 여럿이면 구현이 올바른지 생각해봐라.

** 권장사항 : 공유 객체 하나에는 메서드 하나만 사용

여러 메서드가 필요한 경우 다음을 고려한다.

- 클라이언트에서 잠금 - 클라이언트에서 첫 번째 메서드를 호출하기 전 서버를 잠근다. 마지막 메서드 호출까지 잠금 유지
- 서버에서 잠금 - 서버에 '서버를 잠그고 모든 메서드를 호출 한 후 잠금 해제'하는 메서드를 구현한다. 클라이언트는 이 메서드를 호출한다.
- 연결*adapted* 서버 - 잠금을 수행하는 중간 단계를 생성한다. '서버에서 잠금'과 유사하지만 원래 서버는 변경하지 않는다.

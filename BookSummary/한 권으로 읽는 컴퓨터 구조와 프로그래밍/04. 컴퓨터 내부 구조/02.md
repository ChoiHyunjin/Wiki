# 명령어 집합

명령어: 메모리에서 찾은 쪽지

## 명령어

![3address op](imgs/스크린샷%202023-05-20%20오전%209.04.21.png)

문제 1. 주소가 4비트라 무의미하다.  
-> 그래서 주소 확장 레지스터 사용해서 접근가능하다.  
문제 2. 메모리 위치를 한꺼번에 지정하기 때문에 메모리 블록이 각기 다른 장치에 존재 하는 경우 데이터,메모리 버스가 3벌이 필요하다.  
문제 3. 메모리에 3번(A, B, 결과)을 접근해야 한다.  
-> 그래서 등장한 누산기 및 1주소 명령어  
![1add op](imgs/스크린샷%202023-05-20%20오전%2010.02.14.png)

## 주소 지정 모드

여태까지는 직접 주소 지정.

- 직접 주소 지정: 명령어의 주소값에 있는 값을 값으로 사용.
- 간접 주소 지정: 명령어의 주소값에 있는 값을 주소로 사용.
- 즉시 주소 지정 모드: 명령어의 주소값을 실제 값으로 사용.

## 조건 코드 명령어

덧셈, 뺄셈, 비교 연산에서 조건 코드가 설정된다. 조건 코드를 원하는 값으로 설정하거나, 조건 코드 값을 살펴볼 방법 필요.

- 조건 코드 레지스터 -> 누산기로 복사 : cca
- 누산기 -> 조건 코드 레지스터로 복사 : acc

## 분기 명령어

코드를 선택적으로 실행하기 위해서 프로그램 카운터의 값을 변경할 수 있는 명령어. 일반적으로는 O(오버플로), Z(영), N(음수) 에 따라 분기한다.  
때로 명시적으로 바꿀 필요가 있는데, pca(PC -> 누산기로 복사), apc(누산기 -> PC)를 이럴 때 사용한다.

## 최종 명령어 집합 구성

모드(2bit) | 명령(4bit) | 주소(10bit)

- 모드: 주소 지정 모드 3가지를 위한 비트(00 ~ 10) + 메모리와 관계 없는, 즉 누산기만 필요한 연산(11)
- 명령: 기존 명령(0000~0111) + 분기 명령(1000~1111)

# 마지막 설계(요소 조합)

## 명령어 레지스터

명령어 실행 시 페치와 실행 두 가지로 이뤄진 사이클(=상태 기계)로 실행된다.

- 페치: 메모리에서 명령어 가져옴. 이 명령어는 명령어 레지스터에 저장.

## 데이터 경로와 제어 신호

- 간접 주소 레지스터: 간접 주소 지정 시 읽어온 값 저장 용.
- 레지스터는 다음 클록 틱에 데이터가 저장된다.
- 프로그램 카운터, 메모리도 틱에 맞춰 제어 신호 수행.

## 데이터 흐름 제어

교통을 제어할 장치가 필요하다.  
명령어 처리를 생각해보자. 다음은 페치에 필요한 신호들이다.

- address source가 PC 선택
- 메모리 동작(enable = 1). 그리고 읽기(r/w = 1)로 설정
- 명령어 레지스터 동작(enable = 1).

간접 주소를 메모리로 읽어 오기 위해서는

- add src를 명령어 레지스터로 지정. (명령어 레지스터 주소 부분이 주소 버스에 연결)
  > -> 그럼 주소 버스는 연결/해제가 반복되나?
- 메모리 동작 및 읽기(1)로 설정
- 간접 주소 레지스터 동작.

클록 틱이 지나면 명령어의 주소를 간접 주소 레지스터에 저장한다.  
누산기 값을 주소에 저장하려면

- add src를 간접 주소 레지스터로 설정.
- data bus 동작
- 메모리 동작 및 쓰기(0)로 설정
- PC 증가

이 단계를 추적할 카운터가 필요하다. 이 카운터 값, 명령어의 명령 코드와 모드 부분를 조합해서 제어 신호를 결정한다.  
가장 복잡한 연산이 3단계이므로, 카운터는 2비트여야 한다.

# RISC, CISC 명령어 집합

# 그래픽 처리 장치, GPU, graphics processing unit

그래픽은 값에 맞춰 약 800만 개의 픽셀에 색을 칠해야 한다. 거기에 주파수에 따라 초당 hz수 만큼 새로 그려야한다. 때문에 메모리에 매우 자주 접근한다.  
특화된 작업만 처리하기에 cpu의 모든 기능이 필요치 않다. 또한 병렬화로 성능을 올려야 한다.  
때문에 1.간단한 처리장치가 많고 2.메모리 버스의 폭이 넓다.  
최근에는 다른 용도로도 사용되고 있다. 단순 계산, 인공 지능 등에 사용된다.
